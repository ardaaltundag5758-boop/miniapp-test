<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Stack Ball Telegram Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #4834d4; touch-action: none; }
        #game-ui { 
            position: absolute; inset: 0; display: flex; flex-direction: column; 
            align-items: center; justify-content: space-between; z-index: 100; pointer-events: none; 
        }
        #score { margin-top: 50px; font-size: 50px; font-family: sans-serif; font-weight: 900; color: white; }
        #start-btn { 
            margin-bottom: 100px; padding: 20px 60px; font-size: 24px; background: white; 
            border: none; border-radius: 50px; font-weight: bold; pointer-events: auto;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3); cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body>
    <div id="game-ui">
        <div id="score">0</div>
        <button id="start-btn">BAŞLA</button>
    </div>

    <script>
        let scene, camera, renderer, ball, mainPivot, layers = [], fragments = [];
        let isDown = false, gameActive = false, score = 0;
        let clock = new THREE.Clock();
        
        // --- MOBİL / TELEGRAM AYARLARI ---
        const ROT_SPEED = 1.1;        
        const GRAVITY = -45.0;        
        const JUMP_FORCE = 18.0;      
        const CRUSH_SPEED = -35.0;    
        const RING_DEPTH = 2.2;
        const LAYER_GAP = 0.5; // Görseldeki gibi daha belirgin boşluklar
        const TOTAL_STEP = RING_DEPTH + LAYER_GAP;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x4834d4); 

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.2));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 30, 20);
            scene.add(sun);

            mainPivot = new THREE.Group();
            scene.add(mainPivot);

            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(3.5, 3.5, 1000, 32),
                new THREE.MeshPhongMaterial({ color: 0xffffff }) 
            );
            mainPivot.add(tower);

            ball = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 24, 24),
                new THREE.MeshPhongMaterial({ color: 0xffffff })
            );
            ball.position.set(0, 30, 7.2); 
            scene.add(ball);

            createLevel();

            // Buton için güvenli tıklama
            const btn = document.getElementById('start-btn');
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                startGame();
            });

            // Kontroller
            const handleDown = (e) => { if(gameActive) isDown = true; };
            const handleUp = () => isDown = false;
            
            window.addEventListener('mousedown', handleDown);
            window.addEventListener('mouseup', handleUp);
            window.addEventListener('touchstart', (e) => { handleDown(); }, {passive: false});
            window.addEventListener('touchend', handleUp);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createLevel() {
            for (let i = 0; i < 100; i++) {
                const layerGroup = new THREE.Group();
                layerGroup.position.y = 30 - (i * TOTAL_STEP);
                
                const isBlack = i > 5 && Math.random() < 0.25 && i < 95;
                const color = isBlack ? 0x222222 : (i % 2 === 0 ? 0xffbe76 : 0xf0932b);
                
                const segments = 8; // Görseldeki gibi ayrık ve büyük parçalar
                const angleStep = (Math.PI * 2) / segments;

                for(let j = 0; j < segments; j++) {
                    const shape = new THREE.Shape();
                    // 0.2 payı görseldeki gibi blokların birleşmemesini sağlar
                    shape.absarc(0, 0, 8.5, j * angleStep + 0.2, (j + 1) * angleStep - 0.2, false);
                    shape.absarc(0, 0, 5.0, (j + 1) * angleStep - 0.2, j * angleStep + 0.2, true);

                    const geometry = new THREE.ExtrudeGeometry(shape, { depth: RING_DEPTH, bevelEnabled: false });
                    const material = new THREE.MeshPhongMaterial({ color: color });
                    
                    const piece = new THREE.Mesh(geometry, material);
                    piece.rotation.x = Math.PI / 2;
                    piece.position.y = RING_DEPTH / 2; 
                    piece.userData = { fatal: isBlack, angle: j * angleStep + (angleStep/2) };
                    layerGroup.add(piece);
                }
                layerGroup.rotation.y = i * 0.25; 
                mainPivot.add(layerGroup);
                layers.push(layerGroup);
            }
        }

        function startGame() {
            gameActive = true;
            document.getElementById('start-btn').style.display = 'none';
            clock.start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            let dt = clock.getDelta();
            if (dt > 0.1) dt = 0.016; 

            mainPivot.rotation.y += ROT_SPEED * dt; 

            // Patlama Efekti
            for (let i = fragments.length - 1; i >= 0; i--) {
                const f = fragments[i];
                f.position.add(f.userData.vel.clone().multiplyScalar(dt * 60));
                f.rotation.z += f.userData.rotVel; 
                f.userData.vel.y -= 0.7 * dt * 60; 
                if(f.position.y < -50) { scene.remove(f); fragments.splice(i, 1); }
            }

            if (gameActive) {
                if (isDown) ballVel = CRUSH_SPEED;
                else ballVel += GRAVITY * dt;

                ball.position.y += ballVel * dt;

                for (let i = 0; i < layers.length; i++) {
                    const l = layers[i];
                    const diff = ball.position.y - l.position.y;

                    if (diff < RING_DEPTH && diff > 0 && ballVel < 0) {
                        if (isDown) {
                            if (l.children[0].userData.fatal) {
                                gameActive = false;
                                setTimeout(() => location.reload(), 500);
                                return;
                            }
                            explodeLayer(l);
                            layers.splice(i, 1);
                            score += 10;
                            document.getElementById('score').innerText = score;
                            break; 
                        } else {
                            ballVel = JUMP_FORCE;
                            ball.position.y = l.position.y + RING_DEPTH;
                            break;
                        }
                    }
                }
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, ball.position.y + 18, 5 * dt);
                camera.lookAt(0, ball.position.y - 10, 0);
            }
            renderer.render(scene, camera);
        }

        function explodeLayer(layer) {
            const currentRotation = mainPivot.rotation.y;
            while(layer.children.length > 0) {
                const p = layer.children[0];
                const worldPos = new THREE.Vector3();
                p.getWorldPosition(worldPos);
                mainPivot.remove(p);
                p.position.copy(worldPos);
                const angle = p.userData.angle + currentRotation;
                const force = 1.2 + Math.random();
                p.userData.vel = new THREE.Vector3(Math.cos(angle) * force, 0.8, -Math.sin(angle) * force);
                p.userData.rotVel = (Math.random() - 0.5) * 0.3;
                scene.add(p);
                fragments.push(p);
            }
            mainPivot.remove(layer);
        }

        init();
    </script>
</body>
</html>
