<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stack Ball - Kesin Çözüm</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Arial Black', sans-serif; background: #22a6b3; }
        #game-ui { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; pointer-events: none; }
        #start-btn { 
            padding: 20px 60px; font-size: 28px; font-weight: bold; background: #fff; border: none; 
            border-radius: 50px; cursor: pointer; pointer-events: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
        }
        #score-display { position: absolute; top: 40px; font-size: 60px; font-weight: 900; color: white; text-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    </style>
</head>
<body>
    <div id="game-ui">
        <div id="score-display">0</div>
        <button id="start-btn" onclick="startGame()">BAŞLA</button>
    </div>

    <script>
        let scene, camera, renderer, ball, mainPivot, layers = [], fragments = [];
        let isDown = false, gameActive = false, score = 0;
        
        const START_Y = 30;
        let ballY = START_Y + 5;
        let ballVel = 0; 
        
        // Sabitlenmiş Yavaş Hız Ayarları
        const GRAVITY = 0.005;      
        const JUMP_FORCE = 0.12;     
        const CRUSH_SPEED = 0.35;    
        const ROT_SPEED = 0.008;     
        const LAYER_GAP = 5.5;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x22a6b3);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, ballY + 15, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.0));
            const sun = new THREE.DirectionalLight(0xffffff, 0.4);
            sun.position.set(10, 20, 15);
            scene.add(sun);

            mainPivot = new THREE.Group();
            scene.add(mainPivot);

            // Siyah Direk
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2.5, 2.5, 1000, 48),
                new THREE.MeshPhongMaterial({ color: 0x111111 })
            );
            mainPivot.add(tower);

            // Beyaz Top
            ball = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 32, 32),
                new THREE.MeshPhongMaterial({ color: 0xffffff })
            );
            ball.position.set(0, ballY, 5.2); // Top tam halkanın üzerinde duracak
            scene.add(ball);

            createLevel();

            window.addEventListener('pointerdown', () => { if(gameActive) isDown = true; });
            window.addEventListener('pointerup', () => isDown = false);
            
            animate();
        }

        function createLevel() {
            for (let i = 0; i < 60; i++) {
                const layerGroup = new THREE.Group();
                layerGroup.position.y = START_Y - (i * LAYER_GAP);
                
                const isBlack = i > 5 && Math.random() < 0.2 && i < 58;
                const color = isBlack ? 0x222222 : 0xeb4d4b;
                
                // Tam Daire İçin Dilimleme Mantığı
                const segments = 40; 
                const radius = 5.2;
                const angleStep = (Math.PI * 2) / segments;

                for(let j = 0; j < segments; j++) {
                    // Kutucuk yerine 'CylinderGeometry' kullanarak dilim oluşturuyoruz.
                    // thetaLength parametresi parçaların birbirine tam yapışmasını sağlar.
                    const geometry = new THREE.CylinderGeometry(radius, radius, 1.2, 8, 1, false, j * angleStep, angleStep);
                    const material = new THREE.MeshPhongMaterial({ color: color });
                    const piece = new THREE.Mesh(geometry, material);
                    
                    // İç içe geçmeyi ve boşlukları önlemek için ölçekleme
                    piece.scale.set(0.9, 1, 0.9); 
                    
                    piece.userData = { fatal: isBlack };
                    layerGroup.add(piece);
                }
                
                layerGroup.rotation.y = i * 0.4;
                mainPivot.add(layerGroup);
                layers.push(layerGroup);
            }
        }

        function startGame() {
            gameActive = true;
            document.getElementById('start-btn').style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);

            if(gameActive) mainPivot.rotation.y += ROT_SPEED; 

            for (let i = fragments.length - 1; i >= 0; i--) {
                const f = fragments[i];
                f.position.add(f.userData.vel);
                f.userData.vel.y -= 0.015;
                f.rotation.x += 0.2;
                if(f.position.y < -50) { scene.remove(f); fragments.splice(i, 1); }
            }

            if (gameActive) {
                if (isDown) {
                    ballVel = CRUSH_SPEED;
                    ballY -= ballVel;
                    checkCrush();
                } else {
                    ballVel -= GRAVITY; 
                    ballY += ballVel;

                    const currentLayer = layers.find(l => 
                        ballY <= l.position.y + 2.2 && 
                        ballY >= l.position.y + 0.5 && 
                        ballVel < 0
                    );

                    if (currentLayer) {
                        ballVel = JUMP_FORCE; 
                        ballY = currentLayer.position.y + 2.2;
                    }
                }

                ball.position.y = ballY;
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, ballY + 18, 0.03);
                camera.lookAt(0, ballY - 10, 0);
            }

            renderer.render(scene, camera);
        }

        function checkCrush() {
            const lIdx = layers.findIndex(l => Math.abs(ballY - l.position.y) < 1.8);
            if (lIdx !== -1) {
                const l = layers[lIdx];
                if (l.children[0].userData.fatal) {
                    gameActive = false;
                    setTimeout(() => location.reload(), 300);
                    return;
                }
                explodeLayer(l);
                layers.splice(lIdx, 1);
                score += 10;
                document.getElementById('score-display').innerText = score;
            }
        }

        function explodeLayer(layer) {
            while(layer.children.length > 0) {
                const p = layer.children[0];
                const worldPos = new THREE.Vector3();
                p.getWorldPosition(worldPos);
                mainPivot.remove(p);
                p.position.copy(worldPos);
                p.userData.vel = new THREE.Vector3((Math.random()-0.5)*0.3, 0.15, (Math.random()-0.5)*0.3);
                scene.add(p);
                fragments.push(p);
            }
            mainPivot.remove(layer);
        }

        init();
    </script>
</body>
</html>
